var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable, EventEmitter } from '@angular/core';
import * as MQTT from 'mqtt';
import * as extend from 'xtend';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import { UsingObservable } from 'rxjs/observable/UsingObservable';
import { Subject } from 'rxjs/Subject';
import { Subscription } from 'rxjs/Subscription';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/publishReplay';
import { MqttConnectionState } from './mqtt.model';
var MqttService = MqttService_1 = (function () {
    function MqttService(options) {
        var _this = this;
        this.options = options;
        this.observables = {};
        this.state = new BehaviorSubject(MqttConnectionState.CLOSED);
        this.messages = new Subject();
        this.clientId = 'client-' + Math.random().toString(36).substr(2, 19);
        this.keepalive = 10;
        this.connectTimeout = 10000;
        this.reconnectPeriod = 10000;
        this._onConnect = new EventEmitter();
        this._onClose = new EventEmitter();
        this._onError = new EventEmitter();
        this._onReconnect = new EventEmitter();
        this._onMessage = new EventEmitter();
        this.handleOnClose = function () {
            _this.state.next(MqttConnectionState.CLOSED);
            _this._onClose.emit();
        };
        this.handleOnConnect = function (e) {
            _this.state.next(MqttConnectionState.CONNECTED);
            _this._onConnect.emit(e);
        };
        this.handleOnReconnect = function () {
            _this.state.next(MqttConnectionState.CONNECTING);
            _this._onReconnect.emit();
        };
        this.handleOnError = function (e) {
            _this._onError.emit(e);
            console.error(e);
        };
        this.handleOnMessage = function (topic, msg, packet) {
            _this._onMessage.emit(packet);
            if (packet.cmd === 'publish') {
                _this.messages.next(packet);
            }
        };
        if (options.connectOnCreate === true) {
            this.connect();
        }
        this.state.subscribe();
    }
    MqttService.prototype.connect = function (opts) {
        var options = extend(this.options || {}, opts);
        var protocol = options.protocol || 'ws';
        var hostname = options.hostname || 'localhost';
        var port = options.port || 1884;
        var path = options.path || '/';
        this.url = protocol + "://" + hostname + ":" + port + "/" + path;
        this.client = MQTT.connect(this.url, extend({
            clientId: this.clientId,
            keepalive: this.keepalive,
            reconnectPeriod: this.reconnectPeriod,
            connectTimeout: this.connectTimeout
        }, options));
        this.client.on('connect', this.handleOnConnect);
        this.client.on('close', this.handleOnClose);
        this.client.on('error', this.handleOnError);
        this.client.on('reconnect', this.handleOnReconnect);
        this.client.on('message', this.handleOnMessage);
    };
    MqttService.prototype.disconnect = function () {
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        this.client.end();
    };
    /**
     * With this method, you can observe messages for a mqtt topic.
     * The observable will only emit messages matching the filter.
     * The first one subscribing to the resulting observable executes a mqtt subscribe.
     * The last one unsubscribing this filter executes a mqtt unsubscribe.
     * @param  {string}                  filter
     * @return {Observable<MqttMessage>}        the observable you can subscribe to
     */
    MqttService.prototype.observe = function (filter) {
        var _this = this;
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        if (!this.observables[filter]) {
            this.observables[filter] = UsingObservable
                .create(
            // resourceFactory: Do the actual ref-counting MQTT subscription.
            // refcount is decreased on unsubscribe.
            function () {
                var subscription = new Subscription();
                _this.client.subscribe(filter);
                subscription.add(function () {
                    delete _this.observables[filter];
                    _this.client.unsubscribe(filter);
                });
                return subscription;
            }, 
            // observableFactory: Create the observable that is consumed from.
            // This part is not executed until the Observable returned by
            // `observe` gets actually subscribed.
            function (subscription) { return _this.messages; })
                .filter(function (msg) { return MqttService_1.filterMatchesTopic(filter, msg.topic); })
                .publishReplay(1)
                .refCount();
        }
        return this.observables[filter];
    };
    /**
     * This method publishes a message for a topic with optional options.
     * The returned observable will complete, if publishing was successfull
     * and will throw an error, if the publication fails
     * @param  {string}           topic
     * @param  {any}              message
     * @param  {PublishOptions}   options
     * @return {Observable<void>}
     */
    MqttService.prototype.publish = function (topic, message, options) {
        var _this = this;
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        var source = Observable.create(function (obs) {
            _this.client.publish(topic, message, options, function (err) {
                if (err) {
                    obs.error(err);
                }
                else {
                    obs.complete();
                }
            });
        });
        return source;
    };
    /**
     * This method publishes a message for a topic with optional options.
     * If an error occurs, it will throw.
     * @param  {string}           topic
     * @param  {any}              message
     * @param  {PublishOptions}   options
     */
    MqttService.prototype.unsafePublish = function (topic, message, options) {
        if (!this.client) {
            throw new Error('mqtt client not connected');
        }
        this.client.publish(topic, message, options, function (err) {
            if (err) {
                throw (err);
            }
        });
    };
    /**
     * This static method shall be used to determine whether an MQTT
     * topic matches a given filter. The matching rules are specified in the MQTT
     * standard documenation and in the library test suite.
     *
     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.
     * @param  {string}  topic  A topic may not contain wildcards.
     * @return {boolean}        true on match and false otherwise.
     */
    MqttService.filterMatchesTopic = function (filter, topic) {
        if (filter[0] === '#' && topic[0] === '$') {
            return false;
        }
        // Preparation: split and reverse on '/'. The JavaScript split function is sane.
        var fs = (filter || '').split('/').reverse();
        var ts = (topic || '').split('/').reverse();
        // This function is tail recursive and compoares both arrays one element at a time.
        var match = function () {
            // Cutting of the last element of both the filter and the topic using pop().
            var f = fs.pop();
            var t = ts.pop();
            switch (f) {
                // In case the filter level is '#', this is a match not matter whether
                // the topic is undefined on this level or not ('#'' matches parent element as well!).
                case '#': return true;
                // In case the filter level is '+', we shall dive into the recursion only if t is not undefined.
                case '+': return t ? match() : false;
                // In all other cases the filter level must match the topic level,
                // both must be defined and the filter tail must match the topic
                // tail (which is determined by the recursive call of match()).
                default: return f === t && (f === undefined ? true : match());
            }
        };
        return match();
    };
    Object.defineProperty(MqttService.prototype, "onClose", {
        /**
         * An EventEmitter to listen to close messages
         * onClose.subscribe(() => {
         *     // do something
         * });
         * @type {EventEmitter<void>}
         */
        get: function () {
            return this._onClose;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MqttService.prototype, "onConnect", {
        /**
         * An EventEmitter to listen to connect messages
         * onConnect.subscribe((message: MqttMessage) => {
         *     // do something
         * });
         * @type {EventEmitter<OnConnectEvent>}
         */
        get: function () {
            return this._onConnect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MqttService.prototype, "onReconnect", {
        /**
         * An EventEmitter to listen to reconnect messages
         * onReconnect.subscribe(() => {
         *     // do something
         * });
         * @type {EventEmitter<void>}
         */
        get: function () {
            return this._onReconnect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MqttService.prototype, "onMessage", {
        /**
         * An EventEmitter to listen to message events
         * onMessage.subscribe((e: OnMessageEvent) => {
         *     // do something
         * });
         * @type {EventEmitter<OnMessageEvent>}
         */
        get: function () {
            return this._onMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MqttService.prototype, "onError", {
        /**
         * An EventEmitter to listen to error events
         * onError.subscribe((e: OnErrorEvent) => {
         *     // do something
         * });
         * @type {EventEmitter<OnErrorEvent>}
         */
        get: function () {
            return this._onError;
        },
        enumerable: true,
        configurable: true
    });
    return MqttService;
}());
MqttService = MqttService_1 = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Object])
], MqttService);
export { MqttService };
var MqttService_1;
