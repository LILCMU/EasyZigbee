/// <reference types="mqtt" />
import { EventEmitter } from '@angular/core';
import * as MQTT from 'mqtt';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/publishReplay';
import { MqttConnectionState, MqttMessage, MqttServiceOptions, OnConnectEvent, OnErrorEvent, OnMessageEvent, PublishOptions } from './mqtt.model';
export declare class MqttService {
    private options;
    observables: {
        [filter: string]: Observable<MqttMessage>;
    };
    state: BehaviorSubject<MqttConnectionState>;
    messages: Subject<MQTT.Packet>;
    private client;
    private clientId;
    private keepalive;
    private connectTimeout;
    private reconnectPeriod;
    private url;
    _onConnect: EventEmitter<OnConnectEvent>;
    _onClose: EventEmitter<void>;
    _onError: EventEmitter<OnErrorEvent>;
    _onReconnect: EventEmitter<void>;
    _onMessage: EventEmitter<OnMessageEvent>;
    constructor(options: MqttServiceOptions);
    connect(opts?: MqttServiceOptions): void;
    disconnect(): void;
    /**
     * With this method, you can observe messages for a mqtt topic.
     * The observable will only emit messages matching the filter.
     * The first one subscribing to the resulting observable executes a mqtt subscribe.
     * The last one unsubscribing this filter executes a mqtt unsubscribe.
     * @param  {string}                  filter
     * @return {Observable<MqttMessage>}        the observable you can subscribe to
     */
    observe(filter: string): Observable<MqttMessage>;
    /**
     * This method publishes a message for a topic with optional options.
     * The returned observable will complete, if publishing was successfull
     * and will throw an error, if the publication fails
     * @param  {string}           topic
     * @param  {any}              message
     * @param  {PublishOptions}   options
     * @return {Observable<void>}
     */
    publish(topic: string, message: any, options?: PublishOptions): Observable<void>;
    /**
     * This method publishes a message for a topic with optional options.
     * If an error occurs, it will throw.
     * @param  {string}           topic
     * @param  {any}              message
     * @param  {PublishOptions}   options
     */
    unsafePublish(topic: string, message: any, options?: PublishOptions): void;
    /**
     * This static method shall be used to determine whether an MQTT
     * topic matches a given filter. The matching rules are specified in the MQTT
     * standard documenation and in the library test suite.
     *
     * @param  {string}  filter A filter may contain wildcards like '#' and '+'.
     * @param  {string}  topic  A topic may not contain wildcards.
     * @return {boolean}        true on match and false otherwise.
     */
    static filterMatchesTopic(filter: string, topic: string): boolean;
    private handleOnClose;
    private handleOnConnect;
    private handleOnReconnect;
    private handleOnError;
    private handleOnMessage;
    /**
     * An EventEmitter to listen to close messages
     * onClose.subscribe(() => {
     *     // do something
     * });
     * @type {EventEmitter<void>}
     */
    readonly onClose: EventEmitter<void>;
    /**
     * An EventEmitter to listen to connect messages
     * onConnect.subscribe((message: MqttMessage) => {
     *     // do something
     * });
     * @type {EventEmitter<OnConnectEvent>}
     */
    readonly onConnect: EventEmitter<OnConnectEvent>;
    /**
     * An EventEmitter to listen to reconnect messages
     * onReconnect.subscribe(() => {
     *     // do something
     * });
     * @type {EventEmitter<void>}
     */
    readonly onReconnect: EventEmitter<void>;
    /**
     * An EventEmitter to listen to message events
     * onMessage.subscribe((e: OnMessageEvent) => {
     *     // do something
     * });
     * @type {EventEmitter<OnMessageEvent>}
     */
    readonly onMessage: EventEmitter<OnMessageEvent>;
    /**
     * An EventEmitter to listen to error events
     * onError.subscribe((e: OnErrorEvent) => {
     *     // do something
     * });
     * @type {EventEmitter<OnErrorEvent>}
     */
    readonly onError: EventEmitter<OnErrorEvent>;
}
